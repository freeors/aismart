#define GETTEXT_DOMAIN "rose-lib"

#include "gui/auxiliary/canvas.hpp"

#include "config.hpp"
#include "../../image.hpp"
#include "formatter.hpp"
#include "gettext.hpp"
#include "gui/auxiliary/formula.hpp"
#include "gui/widgets/helper.hpp"
#include "gui/widgets/control.hpp"
#include "wml_exception.hpp"
#include "font.hpp"
#include "area_anim.hpp"
#include "integrate.hpp"
#include "filesystem.hpp"
#include "theme.hpp"

#include "rose_config.hpp"

namespace gui2 {

#define VALIDATE_WITH_DEV_MESSAGE(cond, message, dev_message)             \
	do {                                                                  \
		if(!(cond)) {                                                     \
			wml_exception(#cond                                           \
					, __FILE__                                            \
					, __LINE__                                            \
					, __func__                                            \
					, std::string(message) + "\nextra message: " + dev_message);   \
		}                                                                 \
	} while(0)

static void decode_hdpi_off(const std::string& hdpi_off, int size, bool* result)
{
	memset(result, 0, sizeof(bool) * size);
	if (hdpi_off.empty()) {
		return;
	}

	std::vector<std::string> fields = utils::split(hdpi_off);
	int size2 = fields.size();
	for (int at = 0; at < size; at ++) {
		if (at < size2) {
			result[at] = utils::to_bool(fields[at]);
		} else {
			return;
		}
	}
}

static const tcontrol* canvas_widget = NULL;
class tcanvas_widget_lock
{
public:
	tcanvas_widget_lock(const tcontrol& widget)
	{
		canvas_widget = &widget;
	}
	~tcanvas_widget_lock()
	{
		canvas_widget = NULL;
	}
};

namespace {

/*WIKI
 * @page = GUICanvasWML
 *
 * {{Autogenerated}}
 *
 * = Canvas =
 *
 * A canvas is a blank drawing area on which the user can draw several shapes.
 * The drawing is done by adding WML structures to the canvas.
 */

/*WIKI
 * @page = GUICanvasWML
 * @begin{parent}{name="generic/state/draw/"}
 *
 * == Pre commit ==
 * @begin{tag}{name="pre_commit"}{min="0"}{max="1"}
 *
 * This section contains the pre commit functions. These functions will be
 * executed before the drawn canvas is applied on top of the normal
 * background. There should only be one pre commit section and its order
 * regarding the other shapes doesn't matter. The function has effect on the
 * entire canvas, it's not possible to affect only a small part of the canvas.
 *
 * The section can have one of the following subsections.
 *
 * === Blur ===
 * @begin{tag}{name="blur"}{min="0"}{max="1"}
 *
 * Blurs the background before applying the canvas. This doesn't make sense
 * if the widget isn't semi-transparent.
 *
 * Keys:
 * @begin{table}{config}
 *     depth & unsigned & 0 &            The depth to blur. $
 * @end{table}
 * @end{tag}{name="blur"}
 * @end{tag}{name="pre_commit"}
 */

/***** ***** ***** ***** ***** LINE ***** ***** ***** ***** *****/

/** Definition of a line shape. */
class tline
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the line see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Line
	 *                            for more information.
	 */
	explicit tline(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects) override;

private:
	tformula<unsigned>
		x1_, /**< The start x coordinate of the line. */
		y1_, /**< The start y coordinate of the line. */
		x2_, /**< The end x coordinate of the line. */
		y2_; /**< The end y coordinate of the line. */

	/** The color of the line. */
	Uint32 color_;

	std::string color_str_;

	enum {hdpi_x1, hdpi_y1, hdpi_x2, hdpi_y2, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

tline::tline(const config& cfg)
	: x1_(cfg["x1"])
	, y1_(cfg["y1"])
	, x2_(cfg["x2"])
	, y2_(cfg["y2"])
	, color_(decode_color(cfg["color"]))
	, color_str_(cfg["color"])
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Line ==
 * @begin{tag}{name="line"}{min="0"}{max="-1"}
 * Definition of a line. When drawing a line it doesn't get blended on the
 * surface but replaces the pixels instead. A blitting flag might be added later
 * if needed.
 *
 * Keys:
 * @begin{table}{config}
 *     x1 & f_unsigned & 0 &           The x coordinate of the startpoint. $
 *     y1 & f_unsigned & 0 &           The y coordinate of the startpoint. $
 *     x2 & f_unsigned & 0 &           The x coordinate of the endpoint. $
 *     y2 & f_unsigned & 0 &           The y coordinate of the endpoint. $
 *     color & color & "" &            The color of the line. $
 *     thickness & unsigned & 0 &      The thickness of the line if 0 nothing
 *                                     is drawn. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="line"}
 *
 * <span id="general_variables">Variables:</span>.
 * @begin{table}{formula}
 *     width & unsigned &                 The width of the canvas. $
 *     height & unsigned &                The height of the canvas. $
 *     text & tstring &                   The text to render on the widget. $
 *     text_maximum_width & unsigned &    The maximum width available for the text
 *                                        on the widget. $
 *     text_wrap_mode & int  &            When the text doesn't fit in the
 *                                        available width there are several ways
 *                                        to fix that. This variable holds the
 *                                        best method. (NOTE this is a 'hidden'
 *                                        variable meant to copy state from a
 *                                        widget to its canvas so there's no
 *                                        reason to use this variable and thus
 *                                        its values are not listed and might
 *                                        change without further notice.) $
 *@end{table}
 *
 * The size variables are copied to the window and will be determined at
 * runtime. This is needed since the main window can be resized and the dialog
 * needs to resize accordingly. The following variables are available:
 * @begin{table}{formula}
 *     screen_width & unsigned &        The usable width of the Wesnoth main
 *                                      window. $
 *     screen_height & unsigned &       The usable height of the Wesnoth main
 *                                      window. $
 *     gamemap_width & unsigned &       The usable width of the Wesnoth tmap,
 *                                      if no tmap shown it's the same value as
 *                                      screen_width. $
 *     gamemap_height & unsigned &      The usable height of the Wesnoth tmap,
 *                                      if no tmap shown it's the same value as
 *                                      screen_height. $
 * @end{table}
 *
 * Note when drawing the valid coordinates are:<br>
 * 0 -> width - 1 <br>
 * 0 -> height -1
 *
 * Drawing outside this area will result in unpredictable results including
 * crashing. (That should be fixed, when encountered.)
 */

/*WIKI - unclassified
 * This code can be used by a parser to generate the wiki page
 * structure
 * [tag name]
 * param type_info description
 *
 * param                               Name of the parameter.
 *
 * type_info = ( type = default_value) The info about a optional parameter.
 * type_info = ( type )                The info about a mandatory parameter
 * type_info = [ type_info ]           The info about a conditional parameter
 *                                     description should explain the reason.
 *
 * description                         Description of the parameter.
 *
 *
 *
 *
 * Formulas are a function between brackets, that way the engine can see whether
 * there is standing a plain number or a formula eg:
 * 0     A value of zero
 * (0)   A formula returning zero
 *
 * When formulas are available the text should state the available variables
 * which are available in that function.
 */

/*WIKI
 * @page = GUIVariable
 *
 * {{Autogenerated}}
 *
 * = Variables =
 *
 * In various parts of the GUI there are several variables types in use. This
 * page describes them.
 *
 * == Simple types ==
 *
 * The simple types are types which have one value or a short list of options.
 *
 * @begin{table}{variable_types}
 *     unsigned &                      Unsigned number (positive whole numbers
 *                                     and zero). $
 *     f_unsigned &                    Unsigned number or formula returning an
 *                                     unsigned number. $
 *     int &                           Signed number (whole numbers). $
 *     f_int &                         Signed number or formula returning an
 *                                     signed number. $
 *     bool &                          A boolean value accepts the normal
 *                                     values as the rest of the game. $
 *     f_bool &                        Boolean value or a formula returning a
 *                                     boolean value. $
 *     string &                        A text. $
 *     tstring &                       A translatable string. $
 *     f_tstring &                     Formula returning a translatable string. $
 *
 *     color &                         A string which contains the color, this
 *                                     a group of 4 numbers between 0 and 255
 *                                     separated by a comma. The numbers are red
 *                                     component, green component, blue
 *                                     component and alpha. A color of 0 is not
 *                                     available. An alpha of 255 is fully
 *                                     transparent. Omitted values are set to 0. $
 *
 *     font_style &                    A string which contains the style of the
 *                                     font:
 *                                     @* normal    normal font
 *                                     @* bold      bold font
 *                                     @* italic    italic font
 *                                     @* underline underlined font
 *                                     @-Since SDL has problems combining these
 *                                     styles only one can be picked. Once SDL
 *                                     will allow multiple options, this type
 *                                     will be transformed to a comma separated
 *                                     list. If empty we default to the normal
 *                                     style. Since the render engine is
 *                                     replaced by Pango markup this field will
 *                                     change later on. Note widgets that allow
 *                                     marked up text can use markup to change
 *                                     the font style. $
 *
 *     v_align &                       Vertical alignment; how an item is
 *                                     aligned vertically in the available
 *                                     space. Possible values:
 *                                     @* top    aligned at the top
 *                                     @* bottom aligned at the bottom
 *                                     @* center centered
 *                                     @-When nothing is set or an another
 *                                     value as in the list the item is
 *                                     centered. $
 *
 *     h_align &                       Horizontal alignment; how an item is
 *                                     aligned horizontal in the available
 *                                     space. Possible values:
 *                                     @* left   aligned at the left side
 *                                     @* right  aligned at the right side
 *                                     @* center centered $
 *
 *     f_h_align &                     A horizontal alignment or a formula
 *                                     returning a horizontal alignment. $
 *
 *     border &                        Comma separated list of borders to use.
 *                                     Possible values:
 *                                     @* left   border at the left side
 *                                     @* right  border at the right side
 *                                     @* top    border at the top
 *                                     @* bottom border at the bottom
 *                                     @* all    alias for "left, right, top,
 *                                     bottom" $
 *
 *     scrollbar_mode &                How to show the scrollbar of a widget.
 *                                     Possible values:
 *                                     @* always       The scrollbar is always
 *                                     shown, regardless whether it's required
 *                                     or not.
 *                                     @* never        The scrollbar is never
 *                                     shown, even not when needed. (Note when
 *                                     setting this mode dialogs might
 *                                     not properly fit anymore).
 *                                     @* auto         Shows the scrollbar when
 *                                     needed. The widget will reserve space for
 *                                     the scrollbar, but only show when needed.
 *                                     @* initial_auto Like auto, but when the
 *                                     scrollbar is not needed the space is not
 *                                     reserved.
 *                                     @-Use auto when the list can be changed
 *                                     dynamically eg the game list in the
 *                                     lobby. For optimization you can also
 *                                     use auto when you really expect a
 *                                     scrollbar, but don't want it to be shown
 *                                     when not needed eg the language list
 *                                     will need a scrollbar on most screens. $
 *
 *     resize_mode &                   Determines how an image is resized.
 *                                     Possible values:
 *                                     @* scale        The image is scaled.
 *                                     @* stretch      The first row or column
 *                                     of pixels is copied over the entire
 *                                     image. (Can only be used to scale resize
 *                                     in one direction, else falls
 *                                     back to scale.)
 *                                     @* tile         The image is placed
 *                                     several times until the entire surface
 *                                     is filled. The last images are
 *                                     truncated. $
 *
 *     grow_direction &                Determines how an image is resized.
 *                                     Possible values:
 *                                     @* scale        The image is scaled.
 *                                     @* stretch      The first row or column
 *                                     of pixels is copied over the entire
 *                                     image. (Can only be used to scale resize
 *                                     in one direction, else falls
 *                                     back to scale.)
 *                                     @* tile         The image is placed
 *                                     several times until the entire surface
 *                                     is filled. The last images are
 *                                     truncated. $
 * @end{table}
 * @allow{type}{name="unsigned"}{value="^\d+$"}
 * @allow{type}{name="f_unsigned"}{value="^.+$"}
 * @allow{type}{name="int"}{value="^-?\d+$"}
 * @allow{type}{name="f_int"}{value="^.*$"}
 * @allow{type}{name="bool"}{value="^true|false|yes|no$"}
 * @allow{type}{name="f_bool"}{value="^.*$"}
 * @allow{type}{name="string"}{value="^.*$"}
 * @allow{type}{name="t_string"}{value="^_?.*$"}
 * @allow{type}{name="f_string"}{value="^.*$"}
 * @allow{type}{name="f_tstring"}{value="^_?.*$"}
 *
 * @allow{type}{name="color"}{value="^(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)$"}
 *
 * @allow{type}{name="font_style"}{value="^(normal|bold|italic|underline)?$"}
 * @allow{type}{name="v_align"}{value="^top|bottom|center$"}
 * @allow{type}{name="h_align"}{value="^left|right|center$"}
 * @allow{type}{name="f_h_align"}{value="^.*$"}
 * @allow{type}{name="border"}{value="^(top|bottom|left|right|all)?(,\s*(top|bottom|left|right|all))*$"}
 * @allow{type}{name="scrollbar_mode"}{value="^always|never|auto|initial_auto$"}
 * @allow{type}{name="resize_mode"}{value="^scale|stretch|tile$"}
 * @allow{type}{name="grow_direction"}{value="^horizontal|vertical$"}
 *
 * @remove{type}{name="section"}
 * @remove{type}{name="config"}
 * @remove{type}{name="grid"}
 * == Section types ==
 *
 * For more complex parts, there are sections. Sections contain of several
 * lines of WML and can have sub sections. For example a grid has sub sections
 * which contain various widgets. Here's the list of sections.
 *
 * @begin{table}{variable_types}
 *     section &                       A generic section. The documentation
 *                                     about the section should describe the
 *                                     section in further detail. $
 *
 *     grid &                          A grid contains several widgets. (TODO
 *                                     add link to generic grid page.) $
 * @end{table}
 */

	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void tline::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	uint32_t argb = color_;
	if (color_ == FORMULA_COLOR) {
		tformula<unsigned> f(color_str_);
		argb = f(variables);
	}
	if (argb == 0) {
		return;
	}

	/**
	 * @todo formulas are now recalculated every draw cycle which is a bit silly
	 * unless there has been a resize. So to optimize we should use an extra
	 * flag or do the calculation in a separate routine.
	 */
	const unsigned x1 = x1_(variables) * (hdpi_off_[hdpi_x1]? 1: twidget::hdpi_scale);
	const unsigned y1 = y1_(variables) * (hdpi_off_[hdpi_y1]? 1: twidget::hdpi_scale);
	const unsigned x2 = x2_(variables) * (hdpi_off_[hdpi_x2]? 1: twidget::hdpi_scale);
	const unsigned y2 = y2_(variables) * (hdpi_off_[hdpi_y2]? 1: twidget::hdpi_scale);

	if (x1 == x2 && y1 == y2) {
		return;
	}

	SDL_Color color = uint32_to_color(argb);

	SDL_Renderer* renderer = get_renderer();
	trender_draw_color_lock lock2(renderer, color.r, color.g, color.b, color.a);
	SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
}

/***** ***** ***** ***** ***** Rectangle ***** ***** ***** ***** *****/

/** Definition of a rectangle shape. */
class trectangle
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the rectangle see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Rectangle
	 *                            for more information.
	 */
	explicit trectangle(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the rectangle. */
		y_, /**< The y coordinate of the rectangle. */
		w_, /**< The width of the rectangle. */
		h_; /**< The height of the rectangle. */

	/**
	 * Border thickness.
	 *
	 * If 0 the fill color is used for the entire widget.
	 */
	unsigned border_thickness_;

	/**
	 * The border color of the rectangle.
	 *
	 * If the color is fully transparent the border isn't drawn.
	 */
	uint32_t border_color_;
	std::string border_color_str_;

	/**
	 * The border color of the rectangle.
	 *
	 * If the color is fully transparent the rectangle won't be filled.
	 */
	uint32_t fill_color_;
	std::string fill_color_str_;

	enum {hdpi_x, hdpi_y, hdpi_w, hdpi_h, hdpi_thickness, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

trectangle::trectangle(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, border_thickness_(cfg["border_thickness"])
	, border_color_(decode_color(cfg["border_color"]))
	, border_color_str_(cfg["border_color"].str())
	, fill_color_(decode_color(cfg["fill_color"]))
	, fill_color_str_(cfg["fill_color"].str())
{
	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);

	if (border_color_ == 0) {
		border_thickness_ = 0;
	}
	border_thickness_ *= (hdpi_off_[hdpi_thickness]? 1: twidget::hdpi_scale);
}

void trectangle::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	uint32_t border_color_argb = 0;
	if (border_thickness_) {
		border_color_argb = border_color_ != FORMULA_COLOR? border_color_: tformula<unsigned>(border_color_str_)(variables);
	}
	const uint32_t fill_color_argb = fill_color_ != FORMULA_COLOR? fill_color_: tformula<unsigned>(fill_color_str_)(variables);
	if (!border_color_argb && !fill_color_argb) {
		return;
	}

	/**
	 * @todo formulas are now recalculated every draw cycle which is a  bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */
	const unsigned x = x_(variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	const unsigned y = y_(variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	const unsigned w = w_(variables) * (hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale);
	const unsigned h = h_(variables) * (hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale);

	if (!w || !h) {
		return;
	}

	if ((int)x >= canvas_width || (int)(x + w) <= 0 || (int)y >= canvas_height || (int)(y + h) <= 0) {
		// require use VALIDATE. now for scroll_textbox selection.
		return;
	}
/*
	if ((int)(x + w) > canvas_width || (int)(y + h) > canvas_height) {
	}
*/
	SDL_Color color = uint32_to_color(border_color_argb);

	SDL_Renderer* renderer = get_renderer();

	{
		trender_draw_color_lock lock2(renderer, color.r, color.g, color.b, color.a);
		// draw the border
		SDL_Point points[5];
		for (unsigned i = 0; i < border_thickness_; ++i) {
			const unsigned left = x + i;
			const unsigned right = left + w - (i * 2) - 1;
			const unsigned top = y + i;
			const unsigned bottom = top + h - (i * 2) - 1;

			points[0].x = left;
			points[0].y = top;
			points[1].x = right;
			points[1].y = top;

			points[2].x = right;
			points[2].y = bottom;

			points[3].x = left;
			points[3].y = bottom;

			points[4].x = left;
			points[4].y = top;
			SDL_RenderDrawLines(renderer, points, 5);
		}
	}

	if (fill_color_argb) {
		color = uint32_to_color(fill_color_argb);
		trender_draw_color_lock lock2(renderer, color.r, color.g, color.b, color.a);

		const unsigned left = x + border_thickness_;
		const unsigned right = left + w - (2 * border_thickness_) - 1;
		const unsigned top = y + border_thickness_;
		const unsigned bottom = top + h - (2 * border_thickness_);

		SDL_Rect rect = ::create_rect(left, top, right - left, bottom - top);
		SDL_RenderFillRect(renderer, &rect);

		drawn_rects.push_back(rect);
	}
}

/***** ***** ***** ***** ***** CIRCLE ***** ***** ***** ***** *****/

/** Definition of a circle shape. */
class tcircle
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the circle see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Circle
	 *                            for more information.
	 */
	explicit tcircle(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

private:
	tformula<unsigned>
		x_,       /**< The centre x coordinate of the circle. */
		y_,       /**< The centre y coordinate of the circle. */
		radius_;  /**< The radius of the circle. */

	/** The color of the circle. */
	Uint32 color_;

};

tcircle::tcircle(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, radius_(cfg["radius"])
	, color_(decode_color(cfg["color"]))
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Circle ==
 * @begin{tag}{name="circle"}{min="0"}{max="-1"}
 *
 * Definition of a circle. When drawing a circle it doesn't get blended on
 * the surface but replaces the pixels instead. A blitting flag might be
 * added later if needed.
 *
 * Keys:
 * @begin{table}{config}
 * x      & f_unsigned & 0 &       The x coordinate of the centre. $
 * y      & f_unsigned & 0 &       The y coordinate of the centre. $
 * radius & f_unsigned & 0 &       The radius of the circle if 0 nothing is
 *                                 drawn. $
 * color & color & "" &            The color of the circle. $
 * debug & string & "" &           Debug message to show upon creation this
 *                                 message is not stored. $
 * @end{table}
 * @end{tag}{name="circle"}
 * Variables:
 * See [[#general_variables|Line]].
 *
 * Drawing outside the area will result in unpredictable results including
 * crashing. (That should be fixed, when encountered.)
 */
}

void tcircle::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	/**
	 * @todo formulas are now recalculated every draw cycle which is a bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */

	const unsigned x = x_(variables);
	const unsigned y = y_(variables);
	const unsigned radius = radius_(variables);

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(x - radius) >= 0
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "x = " << x << ", radius = " << radius).str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(y - radius) >= 0
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "y = " << y << ", radius = " << radius).str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(x + radius) < canvas_width
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "x = " << x << ", radius = " << radius
				<< "', canvas width = " << canvas_width << ".").str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(y + radius) < canvas_height
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "y = " << y << ", radius = " << radius
				<< "', canvas height = " << canvas_height << ".").str());
/*
	int ii = 0;
	// lock the surface
	surface_lock locker(canvas);
	draw_circle(canvas, color_, x, y, radius, true);
*/
}

/***** ***** ***** ***** ***** IMAGE ***** ***** ***** ***** *****/

/** Definition of an image shape. */
class timage
	: public tcanvas::tshape
{
public:
	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the image see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Image
	 *                            for more infomation.
	 */
	explicit timage(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the image. */
		y_, /**< The y coordinate of the image. */
		w_, /**< The width of the image. */
		h_; /**< The height of the image. */

	/** The image is cached in this surface. */
	surface image_;



	/**
	 * Name of the image.
	 *
	 * This value is only used when the image name is a formula. If it isn't a
	 * formula the image will be loaded in the constructor. If it's a formula it
	 * will be loaded every draw cycles. This allows 'changing' images.
	 */
	tformula<std::string> image_name_;

	/**
	 * Determines the way an image will be resized.
	 *
	 * If the image is smaller is needed it needs to resized, how is determined
	 * by the value of this enum.
	 */
	enum tresize_mode {
		  scale
		, stretch
		, tile
	};

	/** Converts a string to a resize mode. */
	tresize_mode get_resize_mode(const std::string& resize_mode);

	/** The resize mode for an image. */
	tresize_mode resize_mode_;

	/** Mirror the image over the vertical axis. */
	tformula<bool> vertical_mirror_;

	enum {hdpi_x, hdpi_y, hdpi_w, hdpi_h, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

timage::timage(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, image_()
	, image_name_(cfg["name"])
	, resize_mode_(get_resize_mode(cfg["resize_mode"]))
	, vertical_mirror_(cfg["vertical_mirror"])
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Image ==
 * @begin{tag}{name="image"}{min="0"}{max="-1"}
 * Definition of an image.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the image, if not zero the
 *                                     image will be scaled to the desired
 *                                     width. $
 *     h & f_unsigned & 0 &            The height of the image, if not zero the
 *                                     image will be scaled to the desired
 *                                     height. $
 *     resize_mode & resize_mode & scale &
 *                                     Determines how an image is scaled to fit
 *                                     the wanted size. $
 *     vertical_mirror & f_bool & false &
 *                                     Mirror the image over the vertical axis. $
 *     name & f_string & "" &          The name of the image. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 *
 * @end{table}
 * @end{tag}{name="image"}
 * Variables:
 * @begin{table}{formula}
 *     image_width & unsigned &         The width of the image, either the
 *                                      requested width or the natural width of
 *                                      the image. This value can be used to set
 *                                      the x (or y) value of the image. (This
 *                                      means x and y are evaluated after the
 *                                      width and height.) $
 *     image_height & unsigned &        The height of the image, either the
 *                                      requested height or the natural height
 *                                      of the image. This value can be used to
 *                                      set the y (or x) value of the image.
 *                                      (This means x and y are evaluated after
 *                                      the width and height.) $
 *     image_original_width & unsigned &
 *                                      The width of the image as stored on
 *                                      disk, can be used to set x or w
 *                                      (also y and h can be set). $
 *     image_original_height & unsigned &
 *                                      The height of the image as stored on
 *                                      disk, can be used to set y or h
 *                                      (also x and y can be set). $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 */
	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void timage::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	/**
	 * @todo formulas are now recalculated every draw cycle which is a  bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */
	const std::string name = image_name_(variables);
	if (name.empty()) {
		return;
	}

	/*
	 * The locator might return a different surface for every call so we can't
	 * cache the output, also not if no formula is used.
	 */
	{
		surface tmp;
		if (twidget::hdpi_scale > 1) {
			tmp = image::get_image(image::locator(get_hdpi_name(name, twidget::hdpi_scale)));
		}
		if (!tmp) {
			tmp = image::get_image(image::locator(name));
		}
		if (!tmp) {
			return;
		}
		image_ = tmp;
	}

	game_logic::map_formula_callable local_variables(variables);
	local_variables.add("image_original_width", variant(image_->w));
	local_variables.add("image_original_height", variant(image_->h));

	unsigned w = w_(local_variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(w) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', w = " << static_cast<int>(w) << ".").str());

	unsigned h = h_(local_variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(h) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', h = " << static_cast<int>(h) << ".").str());

	if ((!w && w_.has_formula()) || (!h && h_.has_formula())) { 
		return;
	}

	const unsigned x = x_(local_variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(x) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', x = " << static_cast<int>(x) << ".").str());

	const unsigned y = y_(local_variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(y) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', y = " << static_cast<int>(y) << ".").str());


	// Copy the data to local variables to avoid overwriting the originals.
	SDL_Rect src_clip = ::create_rect(0, 0, image_->w, image_->h);
	SDL_Rect dst_clip = ::create_rect(x, y, 0, 0);
	surface surf;

	// Test whether we need to scale and do the scaling if needed.
	if (w || h) {
		bool done = false;
		bool stretch_image = (resize_mode_ == stretch) && (!!w ^ !!h);

		w *= hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale;
		h *= hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale;

		if (!w) {
			if (stretch_image) {
				// Image: vertical stretch from image_->w, image_->h to a height of h.
				// when strech vertical, app should set hdpi_off_[hdpi_w] to true. but now don't alert.
				surf = stretch_surface_vertical(image_, h, canvas_width / twidget::hdpi_scale);
				done = true;
			}
			w = image_->w * (hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale);
		}

		if (!h) {
			// if h = 0, think use image_original_height. don't conside hdpi_scale.
			if (stretch_image) {
				// Image: horizontal stretch from image_->w, image_->h to a width of w.
				// when strech horizontal, app should set hdpi_off_[hdpi_h] to true. but now don't alert.
				surf = stretch_surface_horizontal(image_, w, canvas_height / twidget::hdpi_scale);
				done = true;
			}
			h = image_->h * (hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale);
		}

		if (!done) {
			if (resize_mode_ == tile) {
				// Image: tiling from image_->w, image_->h to w, h.
				const int columns = (w + image_->w - 1) / image_->w;
				const int rows = (h + image_->h - 1) / image_->h;
				surf = create_neutral_surface(w, h);

				for (int x = 0; x < columns; ++x) {
					for (int y = 0; y < rows; ++y) {
						SDL_Rect dest = ::create_rect(
								  x * image_->w
								, y * image_->h
								, 0
								, 0);
						sdl_blit(image_, NULL, surf, &dest);
					}
				}
				src_clip.w = w;
				src_clip.h = h;

			} else {
				surf = image_;
			}
		} else {
			src_clip.w = w;
			src_clip.h = h;
		}

	} else {
		w = image_->w;
		h = image_->h;

		if (!hdpi_off_[hdpi_w] || !hdpi_off_[hdpi_h]) {
			w *= hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale;
			h *= hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale;
		}
		surf = image_;
	}

	dst_clip.w = w;
	dst_clip.h = h;

	SDL_RendererFlip flip = SDL_FLIP_NONE;
	if (vertical_mirror_(local_variables)) {
		flip = SDL_FLIP_HORIZONTAL;
	}

	bool blend_none = true;
	for (std::vector<SDL_Rect>::const_iterator it = drawn_rects.begin(); it != drawn_rects.end(); ++ it) {
		const SDL_Rect& rect = *it;
		if (SDL_HasIntersection(&rect, &dst_clip)) {
			blend_none = false;
		}
	}

	SDL_Renderer* renderer = get_renderer();
	texture tex = SDL_CreateTextureFromSurface(renderer, surf);
	if (blend_none) {
		SDL_SetTextureBlendMode(tex.get(), SDL_BLENDMODE_NONE);
	} else {
		SDL_SetTextureBlendMode(tex.get(), SDL_BLENDMODE_BLEND);
	}
	SDL_RenderCopyEx(renderer, tex.get(), &src_clip, &dst_clip, 0, NULL, flip);

	drawn_rects.push_back(dst_clip);
}

timage::tresize_mode timage::get_resize_mode(const std::string& resize_mode)
{
	if(resize_mode == "tile") {
		return timage::tile;
	} else if(resize_mode == "stretch") {
		return timage::stretch;
	} else {
		if(!resize_mode.empty() && resize_mode != "scale") {
			// Invalid resize mode 'resize_mode' falling back to 'scale'.;
		}
		return timage::scale;
	}
}

/***** ***** ***** ***** ***** TEXT ***** ***** ***** ***** *****/

/** Definition of a text shape. */
class ttext
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the text see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Text
	 *                            for more information.
	 */
	explicit ttext(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

	void set_default_fields(int font_size, int color_tpl) 
	{ 
		default_font_size_ = font_size; 
		default_color_tpl_ = color_tpl;
	}

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the text. */
		y_, /**< The y coordinate of the text. */
		w_, /**< The width of the text. */
		h_; /**< The height of the text. */

	/** The font size of the text. */
	const unsigned font_size_;

	/** The style of the text. */
	unsigned font_style_;

	/** The color of the text. */
	Uint32 color_;

	std::string color_str_;

	/** The text to draw. */
	tformula<t_string> text_;

	/** The read only switch of the text. */
	tformula<bool> editable_;

	/** The maximum width for the text. */
	tformula<int> maximum_width_;

	// from tcontrol
	int default_font_size_;
	int default_color_tpl_;

	enum {hdpi_x, hdpi_y, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

ttext::ttext(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, font_size_(cfg["font_size"].to_int())
	, font_style_(decode_font_style(cfg["font_style"]))
	, color_(decode_color(cfg["color"]))
	, color_str_(cfg["color"])
	, text_(cfg["text"])
	, editable_(cfg["editable"], false)
	, maximum_width_(cfg["maximum_width"], 0)
	, default_font_size_(0)
	, default_color_tpl_(0)
{
	type = tcanvas::text_shape;

/*WIKI
 * @page = GUICanvasWML
 *
 * == Text ==
 * @begin{tag}{name="text"}{min="0"}{max="-1"}
 * Definition of text.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the text's bounding
 *                                     rectangle. $
 *     h & f_unsigned & 0 &            The height of the text's bounding
 *                                     rectangle. $
 *     font_size & unsigned & &        The size of the text font. $
 *     font_style & font_style & "" &  The style of the text. $
 *     color & color & "" &            The color of the text. $
 *     text & f_tstring & "" &         The text to draw (translatable). $
 *     text_markup & f_bool & false &  Can the text have mark-up? $
 *     maximum_width & f_int & -1 &    The maximum width the text is allowed to
 *                                     be. $
 *     maximum_height & f_int & -1 &   The maximum height the text is allowed
 *                                     to be. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="text"}
 * NOTE alignment could only be done with the formulas, but now with the
 *
 * Variables:
 * @begin{table}{formula}
 *     text_width & unsigned &            The width of the rendered text. $
 *     text_height & unsigned &           The height of the rendered text. $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 * @end{parent}{name="generic/state/draw/"}
 */

	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void ttext::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	int font_size = default_font_size_;
	if (font_size_ && font_size_ != font_cfg_reference_size) {
		if (font_size_ < font_min_cfg_size) {
			// fixed font size.
			font_size = font_size_ * twidget::hdpi_scale;
		} else {
			font_size = font_hdpi_size_from_cfg_size(font_size_);
		}
	}
	VALIDATE(font_size, _("Text has a font size of 0."));

	uint32_t argb = color_;
	if (color_ == FORMULA_COLOR) {
		tformula<unsigned> f(color_str_);
		argb = f(variables);
	} else if (color_ >= PREDEFINE_COLOR && color_ < PREDEFINE_COLOR + theme::tpl_colors) {
		argb = theme::text_color_from_index(default_color_tpl_, color_ - PREDEFINE_COLOR);
	}

	VALIDATE(variables.has_key("text"), null_str);

	// We first need to determine the size of the text which need the rendered
	// text. So resolve and render the text first and then start to resolve
	// the other formulas.
	const std::string text = text_(variables);

	if (text.empty()) {
		// Text: no text to render, leave.
		return;
	}

	surface surf;
	if (!share_canvas_integrate) {
		const int maximum_width = maximum_width_(variables) * twidget::hdpi_scale;
		bool text_editable = editable_(variables);
		surf = font::get_rendered_text(text, maximum_width, font_size, uint32_to_color(argb), text_editable);
	} else {
		surf = share_canvas_integrate->get_surface();
	}

	if (!surf.get() || surf->w == 0) {
		// Text: Rendering, resulted in an empty canvas, leave.
		return;
	}

	game_logic::map_formula_callable local_variables(variables);
	local_variables.add("text_width", variant(surf->w / twidget::hdpi_scale));
	local_variables.add("text_height", variant(surf->h / twidget::hdpi_scale));

	// @todo formulas are now recalculated every draw cycle which is a
	// bit silly unless there has been a resize. So to optimize we should
	// use an extra flag or do the calculation in a separate routine.

	const unsigned x = x_(local_variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	const unsigned y = y_(local_variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	const unsigned w = w_(local_variables) * twidget::hdpi_scale;
	const unsigned h = h_(local_variables) * twidget::hdpi_scale;

	if (share_canvas_integrate) {
		share_canvas_integrate->set_layout_offset(x, y);
	}

	if ((int)x >= canvas_width || (int)y >= canvas_height) {
		// Text doesn't start on canvas.
		return;
	}

	// A text might be to long and will be clipped.
	SDL_Rect clip = ::create_rect(0, 0, surf->w, surf->h);
	if (surf->w > canvas_width) {
		// Text: text is too wide for the canvas and will be clipped.;
		// clip.x += (surf->w - canvas->w) / 2;
		// clip.w -= surf->w - canvas->w;
	}

	if (surf->h > canvas_height) {
		// Text: text is too high for the canvas and will be clipped.
		// extract center. when one line text, top/button aybe hollow.
		clip.y += (surf->h - canvas_height) / 2;
		clip.h -= surf->h - canvas_height;
	}


	const SDL_Rect dst = ::create_rect(x, y, clip.w, clip.h);
	bool blend_none = true;
	for (std::vector<SDL_Rect>::const_iterator it = drawn_rects.begin(); it != drawn_rects.end(); ++ it) {
		const SDL_Rect& rect = *it;
		if (SDL_HasIntersection(&rect, &dst)) {
			blend_none = false;
		}
	}

	// tsurface_blend_none_lock lock(surf);

	if (blend_none) {
		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
	} else {
		SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_BLEND);
	}
	render_surface(get_renderer(), surf, &clip, &dst);

	drawn_rects.push_back(dst);
}

class tblit
	: public tcanvas::tshape
{
public:
	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the image see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Image
	 *                            for more infomation.
	 */
	explicit tblit(const config& cfg);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

private:
	void post_handle(texture& canvas, const int canvas_width, const int canvas_height);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the image. */
		y_, /**< The y coordinate of the image. */
		w_, /**< The width of the image. */
		h_; /**< The height of the image. */
	std::string post_;

	enum {hdpi_x, hdpi_y, hdpi_w, hdpi_h, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

tblit::tblit(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, post_(cfg["post"].str())
{
	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void tblit::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	unsigned w = w_(variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(w) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "w = " << static_cast<int>(w) << ".").str());

	unsigned h = h_(variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(h) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "h = " << static_cast<int>(h) << ".").str());

	if ((!w && w_.has_formula2()) || (!h && h_.has_formula2())) { 
		return;
	}
	if (!w) {
		w = canvas_width;
	} else {
		w *= hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale;
	}
	if (!h) {
		h = canvas_height;
	} else {
		h *= hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale;
	}

	const unsigned x = x_(variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(x) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "x = " << static_cast<int>(x) << ".").str());

	const unsigned y = y_(variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(y) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "y = " << static_cast<int>(y) << ".").str());

	SDL_Renderer* renderer = get_renderer();

	game_logic::map_formula_callable variables2;
	variables2.add("width", variant(w));
	variables2.add("height", variant(h));
	const std::vector<tformula_blit>& blits = canvas_widget->get_blits();
	for (std::vector<tformula_blit>::const_iterator it = blits.begin(); it != blits.end(); ++ it) {
		tformula_blit blit = *it;
		if (blit.type == image::BLITM_SURFACE && blit.width == tformula_blit::SURF_RATIO_CENTER && blit.height == tformula_blit::SURF_RATIO_CENTER) {
			VALIDATE(blit.surf, null_str);
			tpoint size = calculate_adaption_ratio_size(w, h, blit.surf->w, blit.surf->h);
			if (blit.x == tformula_blit::SURF_RATIO_LT) {
				blit.x = 0;
			} else {
				VALIDATE(blit.x == tformula_blit::SURF_RATIO_CENTER, null_str);
				blit.x = (w - size.x) / 2;
			}
			if (blit.y == tformula_blit::SURF_RATIO_LT) {
				blit.y = 0;
			} else {
				VALIDATE(blit.y == tformula_blit::SURF_RATIO_CENTER, null_str);
				blit.y = (h - size.y) / 2;
			}
			blit.width = size.x;
			blit.height = size.y;
		}
		if (blit.x == MAGIC_COORDINATE_X) {
			blit.x = blit.formula_x(variables2);
		}
		if (blit.y == MAGIC_COORDINATE_X) {
			blit.y = blit.formula_y(variables2);
		}
		if (blit.width == MAGIC_COORDINATE_X) {
			blit.width = blit.formula_width(variables2);
		}
		if (blit.height == MAGIC_COORDINATE_X) {
			blit.height = blit.formula_height(variables2);
		}
		if (blit.type == image::BLITM_LINE) {
			blit.width = blit.width - blit.x + 1;
			blit.height = blit.height - blit.y + 1;
		}
		image::render_blit(renderer, blit, x, y);
	}
	post_handle(canvas, canvas_width, canvas_height);

	drawn_rects.push_back(SDL_Rect{0, 0, canvas_width, canvas_height});
}

void tblit::post_handle(texture& canvas, const int canvas_width, const int canvas_height)
{
	// ~CS()~CS(50,50,50)
	const std::vector<std::string> modlist = utils::parenthetical_split(post_, '~');

	BOOST_FOREACH (const std::string& s, modlist) {
		const std::vector<std::string> tmpmod = utils::parenthetical_split(s);
		std::vector<std::string>::const_iterator j = tmpmod.begin();
		while (j!= tmpmod.end()){
			const std::string function = *j++;
			if (j == tmpmod.end()){
				if(function.size()){
					// error parsing image modifications val_.modifications_;
				}
				break;
			}
			const std::string field = *j++;
			typedef std::pair<Uint32,Uint32> rc_entry_type;

			// Grayscale (GS)
			if ("GS" == function) {
				// functor_queue.push_back(new gs_function());
				grayscale_renderer(get_renderer());
			}
			// Color-shift (CS)
			else if("CS" == function) {
				std::vector<std::string> const factors = utils::split(field, ',');
				const size_t s = factors.size();
				if (s) {
					int r = 0, g = 0, b = 0;

					r = lexical_cast_default<int>(factors[0]);
					if (s > 1) {
						g = lexical_cast_default<int>(factors[1]);
					}
					if (s > 2) {
						b = lexical_cast_default<int>(factors[2]);
					}

					brighten_renderer(get_renderer(), r, g, b, NULL);
				}
			}
		}
	}
}

/***** ***** ***** ***** ***** ANIMATION ***** ***** ***** ***** *****/

/** Definition of a animation shape. */
class tanim
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the text see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Text
	 *                            for more information.
	 */
	explicit tanim(const config& cfg, size_t position);

	/** Implement shape::draw(). */
	void draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects);

public:
	size_t position_;
	config cfg_;
	int id_;
};

tanim::tanim(const config& cfg, size_t position)
	: position_(position)
	, cfg_(cfg)
	, id_(nposm)
{
	type = tcanvas::anim_shape;
/*WIKI
 * @page = GUICanvasWML
 *
 * == Text ==
 * @begin{tag}{name="text"}{min="0"}{max="-1"}
 * Definition of text.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the text's bounding
 *                                     rectangle. $
 *     h & f_unsigned & 0 &            The height of the text's bounding
 *                                     rectangle. $
 *     font_size & unsigned & &        The size of the text font. $
 *     font_style & font_style & "" &  The style of the text. $
 *     color & color & "" &            The color of the text. $
 *     text & f_tstring & "" &         The text to draw (translatable). $
 *     text_markup & f_bool & false &  Can the text have mark-up? $
 *     maximum_width & f_int & -1 &    The maximum width the text is allowed to
 *                                     be. $
 *     maximum_height & f_int & -1 &   The maximum height the text is allowed
 *                                     to be. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="text"}
 * NOTE alignment could only be done with the formulas, but now with the
 *
 * Variables:
 * @begin{table}{formula}
 *     text_width & unsigned &            The width of the rendered text. $
 *     text_height & unsigned &           The height of the rendered text. $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 * @end{parent}{name="generic/state/draw/"}
 */
}

void tanim::draw(texture& canvas, const int canvas_width, const int canvas_height, const game_logic::map_formula_callable& variables, std::vector<SDL_Rect>& drawn_rects)
{
	draw_canvas_anim(id_, canvas, ::create_rect(0, 0, canvas_width, canvas_height), true);
}

} // namespace

/***** ***** ***** ***** ***** CANVAS ***** ***** ***** ***** *****/

tcanvas::tcanvas()
	: shapes_()
	, blur_depth_(0)
	, w_(0)
	, h_(0)
	, canvas_()
	, variables_()
	, dirty_(true)
	, anims_()
	, mixed_(false)
{
}

tcanvas::~tcanvas()
{
	for (std::map<size_t, int>::const_iterator it = anims_.begin(); it != anims_.end(); ++ it) {
		anim2::manager::instance->erase_area_anim(it->second);
	}
}

void tcanvas::draw(const tcontrol& widget, const SDL_Rect& canvas_clip_rect, bool force, const std::vector<int>& post_anims)
{
	bool animated = !anims_.empty() || !post_anims.empty();
	if (!animated && share_canvas_integrate && share_canvas_integrate->exist_anim()) {
		animated = true;
	}

	if (!dirty_ && !force && !animated) {
		// Canvas: nothing to draw.
		return;
	}

	if (dirty_) {
		get_screen_size_variables(variables_);
		variables_.add("width", variant(w_ / twidget::hdpi_scale));
		variables_.add("height", variant(h_ / twidget::hdpi_scale));
		variables_.add("dwidth", variant(w_));
		variables_.add("dheight", variant(h_));
		variables_.add("extra_width", variant(widget.config()->text_extra_width / twidget::hdpi_scale));
		variables_.add("extra_height", variant(widget.config()->text_extra_height / twidget::hdpi_scale));
	}

	SDL_Renderer* renderer = get_renderer();

	// below will change target. require save/recover clip setting of preview target.
	texture_clip_rect_setter clip(NULL);

	if (dirty_ || force || !animated || mixed_) {
		// create surface
		canvas_ = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, w_, h_);
		SDL_SetTextureBlendMode(canvas_.get(), SDL_BLENDMODE_BLEND);
		trender_target_lock lock(renderer, canvas_);
		SDL_RenderClear(renderer);

/*
		int ii = 0;
		if (share_canvas_integrate) {
			share_canvas_integrate->draw_bubble_shape(canvas_, variables_);
		}
*/

		// draw items
		std::vector<SDL_Rect> drawn_rects;
		for (std::vector<tshape_ptr>::iterator itor = shapes_.begin(); itor != shapes_.end(); ++ itor) {
			tshape& shape = **itor;
			if (shape.type == text_shape) {
				// this is text shape
				ttext* text = dynamic_cast<ttext*>(&shape);
				text->set_default_fields(widget.get_text_font_size(), widget.get_text_color_tpl());

			} else if (shape.type == anim_shape) {
				// this is animation shape
				tanim* anim = dynamic_cast<tanim*>(&shape);
				anim->id_ = anims_.find(anim->position_)->second;
			} 

			shape.draw(canvas_, w_, h_, variables_, drawn_rects);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_draw(canvas_, canvas_clip_rect);
		}

		for (std::vector<int>::const_iterator itor = post_anims.begin(); itor != post_anims.end(); ++ itor) {
			draw_canvas_anim(*itor, canvas_, ::create_rect(0, 0, w_, h_), true);
		}

	} else {
		trender_target_lock lock(renderer, canvas_);

		// undraw
		for (std::vector<int>::const_reverse_iterator ritor = post_anims.rbegin(); ritor != post_anims.rend(); ++ ritor) {
			float_animation& anim = *dynamic_cast<float_animation*>(&anim2::manager::instance->area_anim(*ritor));
			anim.undraw(canvas_);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_undraw(canvas_, canvas_clip_rect);
		}

		for (std::vector<tshape_ptr>::reverse_iterator ritor = shapes_.rbegin(); ritor != shapes_.rend(); ++ ritor) {
			if ((*ritor)->type != anim_shape) {
				break;
			}
			// this is animation shape
			int id = anims_.find(dynamic_cast<tanim*>(&**ritor)->position_)->second;
			float_animation& anim = *dynamic_cast<float_animation*>(&anim2::manager::instance->area_anim(id));
			anim.undraw(canvas_);
		}

		std::vector<SDL_Rect> drawn_rects;
		for (std::vector<tshape_ptr>::iterator itor = shapes_.begin(); itor != shapes_.end(); ++itor) {
			if ((*itor)->type == anim_shape) {
				// this is animation shape
				tanim* anim = dynamic_cast<tanim*>(&**itor);
				anim->id_ = anims_.find(anim->position_)->second;
			} else {
				continue;
			}

			(*itor)->draw(canvas_, w_, h_, variables_, drawn_rects);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_draw(canvas_, canvas_clip_rect);
		}

		for (std::vector<int>::const_iterator itor = post_anims.begin(); itor != post_anims.end(); ++ itor) {
			draw_canvas_anim(*itor, canvas_, ::create_rect(0, 0, w_, h_), false);
		}
	} 

	dirty_ = false;
}

void tcanvas::blit(const tcontrol& widget, texture& surf, SDL_Rect rect, bool force, const std::vector<int>& post_anims)
{
	if (shapes_.empty()) {
		return;
	}

	SDL_Rect clip_rect;
	{
		SDL_RenderGetClipRect(get_renderer(), &clip_rect);
		if (SDL_RectEmpty(&clip_rect)) {
			clip_rect.w = w_;
			clip_rect.h = h_;
		}

		SDL_Rect r;
		SDL_IntersectRect(&clip_rect, &rect, &r);
		clip_rect = ::create_rect(r.x - rect.x, r.y - rect.y, r.w, r.h);

		if (clip_rect.w <= 0 || clip_rect.h <= 0) {
			return;
		}

		tcanvas_widget_lock lock(widget);
		draw(widget, clip_rect, force, post_anims);
	}

	// clip texture after fragment-shader, as possible as copy accurately.
	SDL_Rect dstrect = ::create_rect(rect.x + clip_rect.x, rect.y + clip_rect.y, clip_rect.w, clip_rect.h);
	SDL_RenderCopy(get_renderer(), canvas_.get(), &clip_rect, &dstrect);
}

texture tcanvas::get_canvas_tex(tcontrol& widget, const std::vector<int>& post_anims)
{
	tcanvas_widget_lock lock(widget);

	SDL_Rect clip_rect = {0, 0, (int)w_, (int)h_};
	draw(widget, clip_rect, true, post_anims);
	return canvas_;
}

void tcanvas::parse_cfg(const config& cfg, std::vector<tshape_ptr>& shapes, unsigned* blur_depth)
{
	shapes.clear();

	BOOST_FOREACH(const config::any_child& shape, cfg.all_children_range()) {
		const std::string &type = shape.key;
		const config &data = shape.cfg;

		// Canvas: found shape of the type 'type'.

		if (type == "line") {
			shapes.push_back(new tline(data));
		} else if (type == "rectangle") {
			shapes.push_back(new trectangle(data));
		} else if (type == "circle") {
			shapes.push_back(new tcircle(data));
		} else if (type == "image") {
			shapes.push_back(new timage(data));
		} else if (type == "text") {
			shapes.push_back(new ttext(data));
		} else if (type == "blit") {
			shapes.push_back(new tblit(data));
		} else if (type == "anim") {
			shapes.push_back(new tanim(data, shapes.size()));
		} else if (type == "pre_commit") {

			/* note this should get split if more preprocessing is used. */
			BOOST_FOREACH (const config::any_child& function,
					data.all_children_range()) {

				if (function.key == "blur") {
					if (blur_depth) {
						*blur_depth = function.cfg["depth"];
					}
				} else {
					// Canvas: found a pre commit function of an invalid type 'type'.
				}
			}

		} else {
			// Canvas: found a shape of an invalid type 'type'.
			std::stringstream err;
			err << "Canvas: found a shape of an invalid type: " << type;
			VALIDATE(false, err.str());
		}
	}
}

bool tcanvas::start_animation()
{
	for (std::vector<tshape_ptr>::iterator it = shapes_.begin(); it != shapes_.end(); ++ it) {
		if ((*it)->type != anim_shape) {
			if (!mixed_ && !anims_.empty()) {
				mixed_ = true;
			}
			continue;
		}
		// this is animation shape
		tanim* anim = dynamic_cast<tanim*>(&**it);
		int id = start_cycle_float_anim(anim->cfg_);
		if (id == nposm) {
			continue;
		}
		anims_.insert(std::make_pair(anim->position_, id));
	}
	return !anims_.empty();
}

void tcanvas::clear_texture()
{
	if (canvas_.get()) {
		canvas_ = NULL;
		dirty_ = true;
	}
}

/***** ***** ***** ***** ***** SHAPE ***** ***** ***** ***** *****/

} // namespace gui2
/*WIKI
 * @page = GUICanvasWML
 * @order = ZZZZZZ_footer
 *
 * [[Category: WML Reference]]
 * [[Category: GUI WML Reference]]
 *
 */

/*WIKI
 * @page = GUIVariable
 * @order = ZZZZZZ_footer
 *
 * [[Category: WML Reference]]
 * [[Category: GUI WML Reference]]
 */
